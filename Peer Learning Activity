Peer Learning Activity. 
Code Review: Understanding network protocols implementation in Linux
This is a team work and involves third parts. First, understanding the network implementation in Linux and making a team report, with individually made sub-sections. Second: identifying one specific network protocol (among the several that are given) and making a group presentation (demos of the protocol implementation in action are accepted as a part of the presentation, although not expected. This is more of a code review presentation, rather than a demo in action). Third: actively participating in all the other teams’ presentations.

This is a peer learning activity. The team report is received as a group. However, the report should clearly highlight individual contributions and the grading will reflect the actual contributions of each team member. Similarly, the presentation is graded individually for each student’s own contribution in the presentation and participation points awarded for active participation in others’ presentations (through questions, discussions, and attentive listening and engagement. Points are deducted for those who indulge in their mobile phone or their own computer during peer presentations). 

Students are free to form their own team of 3 members and reach a consensus on the protocol to learn and present. Students could also first register their interest in a protocol and let others join the protocol until it reaches 3. We have 46 students and are aiming for 16 teams.

Consult with the instructor if you have questions.
The Report Component
For this assignment, please go through the network implementation of Linux at https://github.com/torvalds/linux/tree/master/net
Then, write your observations and elaborations for each of the folder in the net directory above.
You can start this assignment with cloning the repository locally. Install Git to start! Then fetch the Linux code from GitHub.
$ git clone https://github.com/torvalds/linux.git
$ cd linux/net
Git works well in Windows too. https://git-scm.com/downloads/win You should be able to install the program by going through this URL. You also could browse the source code from Github using just the browser. But it may be less efficient as Git's browser-based interface may not be optimal to trace different files in a large source tree. Once you are in the folder as above, in Linux, you could use the "tree" command to see the folder hierarchy. In windows, the command is cmd //c tree as shown below. 
$ cmd //c tree
Folder PATH listing for volume Windows
Volume serial number is FEDE-927C
C:.
├───6lowpan
├───802
├───8021q
├───9p
├───appletalk
├───atm
├───ax25
├───batman-adv
├───bluetooth
│   ├───bnep
│   ├───cmtp
│   ├───hidp
│   └───rfcomm
├───bpf
├───bridge
│   └───netfilter
├───caif
├───can
│   └───j1939
├───ceph
│   └───crush
├───core
├───dcb
├───dccp
│   └───ccids
│       └───lib
├───devlink
├───dns_resolver
├───dsa
├───ethernet
├───ethtool
├───handshake
├───hsr
├───ieee802154
│   └───6lowpan
├───ife
├───ipv4
│   └───netfilter
├───ipv6
│   ├───ila
│   └───netfilter
├───iucv
├───kcm
├───key
├───l2tp
├───l3mdev
├───lapb
├───llc
├───mac80211
│   └───tests
├───mac802154
├───mctp
│   └───test
├───mpls
├───mptcp
├───ncsi
├───netfilter
│   ├───ipset
│   └───ipvs
├───netlabel
├───netlink
├───netrom
├───nfc
│   ├───hci
│   └───nci
├───nsh
├───openvswitch
├───packet
├───phonet
├───psample
├───qrtr
├───rds
├───rfkill
├───rose
├───rxrpc
├───sched
├───sctp
├───smc
├───strparser
├───sunrpc
│   ├───auth_gss
│   └───xprtrdma
├───switchdev
├───tipc
├───tls
├───unix
├───vmw_vsock
├───wireless
│   ├───certs
│   └───tests
├───x25
├───xdp
└───xfrm
Use that output (also listed here for your quick reference) to learn the different protocol implementations. Use these folder names as section headers as shown in the template later in this document.
A smarter and practical approach would be to use an IDE to open up the entire folder hierarchy of the "net" folder above, so each folder and files could be viewed from the IDE.
Your task is to reflect on each of these items by going through the source code in each folder. Write the summary and your understanding of each module. Of course, you are a team, and working on the report as a team. So, split the modules evenly among the teammates. You  use the folder names as section headers as shown later in the document. But to identify, learn, and summarize the implementations, you will need to open individual files and read them. For example, https://github.com/torvalds/linux/blob/master/net/dcb/dcbnl.c If you open it, it has sufficient information to present the implementation in the comments and code. Reading a c code can be challenging if you are unfamiliar with the language. You can discuss with your teammates when you need help. It is a peer learning activity after all.
Please use your own words. Do not use references other than this Linux network source code. Do not use ChatGPT or other online links to summarize the code for you. Ability to understand large source code repositories is a critical skill. You could use ChatGPT to understand any code segment that you do not understand. But do not ask it to write a summary of the module for you. The writing itself should be in your own words.
The Presentation Component
Choose one protocol from the list and prepare a group presentation. Let’s avoid multiple teams choosing the same topic. Register your interest in the Discussion Forum once you have finalized the topic and formed a team (or finalized the protocol, but are looking for teammates). Choose on of the below from https://github.com/torvalds/linux/tree/master/net/ and make a presentation for around 8 minutes. Add sufficient information that can be covered in 8 minutes. Do not go overtime. And do not make the presentation too short either. Going too short is a waste of your time. Going overtime will annoy the audience and you may be cut short (since we do not have a lot of time – and only two classes for all the team presentations). Try to choose more diverse topics (instead of choosing TCP, UDP, Ethernet, or IPv4).
You will be asked to present on the week of October 21st (October 21st or October 23rd). Do not miss the classes if you do not want to miss the two points (and it will be nice to listen to your classmates' presentations anyway!)
├───6lowpan
├───802
├───8021q
├───9p
├───appletalk
├───atm
├───ax25
├───batman-adv
├───bluetooth/bnep
├───bluetooth/cmtp
├───bluetooth/hidp
├───bluetooth/rfcomm
├───bpf
├───bridge/netfilter
├───caif
├───can
├───ceph
├───core
├───dcb
├───dccp
├───devlink
├───dns_resolver
├───dsa
├───ethernet
├───ethtool
├───handshake
├───hsr
├───ieee802154
├───ife
├───ipv4
├───ipv6/ila
├───ipv6/netfilter
├───iucv
├───kcm
├───key
├───l2tp
├───l3mdev
├───lapb
├───llc
├───mac80211
├───mac802154
├───mctp
├───mpls
├───mptcp
├───ncsi
├───netfilter/ipset
├───netfilter/ipvs
├───netlabel
├───netlink
├───netrom
├───nfc/hci
├───nfc/nci
├───nsh
├───openvswitch
├───packet
├───phonet
├───psample
├───qrtr
├───rds
├───rfkill
├───rose
├───rxrpc
├───sched
├───sctp
├───smc
├───strparser
├───sunrpc/auth_gss
├───sunrpc/xprtrdma
├───switchdev
├───tipc
├───tls
├───unix
├───vmw_vsock
├───wireless
├───x25
├───xdp
└───xfrm
Please upload the presentation here before the due date, together with the report. But grading for the presentation is done for your actual presentation. Skipping either the actual presentation, forgetting to upload the presentation slides on time, or forgetting to upload the report on time—all will lead to reduction in points.
Rubric
The assignment is evaluated across the two different deliverables. Each aspect is judged on a scale of 0 – 4, from 0 being “Ungradable” to 4 being “Excellent. 
Excellent (4): The work is either perfect or has negligible flaws.
Good (3): The work is of good quality. Only minor revisions would be needed for the work to be Excellent.
Satisfactory (2): While the work has some room for improvement, the student has put in a good-faith effort to complete all the work and demonstrated sufficient mastery of the material. A few revisions would be needed for the work to be considered Good.
Needs Improvement (1): The student has put in a good-faith effort to complete the work, but revealed a lack of mastery in the material that can be addressed via concrete feedback. The work could become Satisfactory or better with some major revisions.
Ungradable (0): The student did not make a good-faith effort to complete the work. This includes not submitting the (relevant part of) work at all, but also situations like submitting only placeholder code or code segments merely taken from the textbook.
The grading aspects:
Group Report: Only one submission expected from each team. Each group summarize their learning in this collectively-made report. The report should detail the findings about each of the protocol in the student’s own words. Please make sure to address all the sections as noted in the template below to secure 4/4 for the report component (otherwise, partial scores will apply as detailed in the rubric).
Group Presentation: Ability to explain the findings to educate others in the selected protocol. This presentation is about just one protocol – rather than everything, while the report covers all the protocols.
The report demonstrates YOUR learning abilities. The group presentation demonstrates how you educate others on this topic through a code-review/presentation. After all, you will be presenting a protocol that is not yet covered in class (or insufficiently covered). The remaining two points come from participation in the Peer Learning Activity Discussions, which are graded 0, 1, or 2. (Partial points such as 0.5 and 1.5 are possible based on situations).
Absent (0): The student was not present during the discussions.
Passive (1): The student was present but largely passive and did not contribute to the conversations or discussions.
Active (2): The student was active throughout the Peer Learning Discussion. They asked questions, clarified points, and made positive contributions to the peer learning aspect of other teams’ projects.
What we learn from this peer learning activity
The goal is to promote peer learning and code review skills in the context of Linux network implementations. That is achieved through two steps. First, teams of varying sizes are formed, and students work within these teams. Subsequently, each team writes a group report (a report template is attached to the end of this assignment). Second, a presentation based on the code review of a given protocol implementation by each team on the date as set on the Syllabus takes the form of Peer Learning Activity Discussions led by students. Although the activity is a team-based endeavor, it is graded individually. Therefore, everyone must contribute to a sufficient number of protocols in the report, and actively take part in the group presentation. Explain and speak for around 2.5 - 3 minutes as individuals, to make the 8 minute group presentation. If you miss your presentation, you will lose all 4 points for the presentation component and the participation points for the day. If your team (whoever among the team responsible to submit those) submits the project report or presentation slides late, you will receive a late penalty for the entire grade 10. It is your responsibility as a student to make sure your team has made the submission on time. Make sure to designate someone to take care of the upload and confirm with them they have uploaded them on time. The Report Template is on the next page.
Peer Learning Activity
Team members at the time of group creation (indicate the full names):
STUDENT1 LASTNAME1
STUDENT2 LASTNAME2
STUDENT3 LASTNAME3

The team members who actively wrote this report (Drop anyone who did not contribute to this report. Feel free to add clarifications and notes to assist the instructor in grading this fairly):
STUDENT1 LASTNAME1
STUDENT2 LASTNAME2

The protocol chosen for the presentation: (Make sure to also submit the presentation slides when you submit this report).
Student contributions:
STUDENT1 wrote the summaries for the protocols: (List all the protocols that STUDENT1 worked on).
STUDENT2 wrote the summaries for the protocols: (List all the protocols that STUDENT2 worked on).
STUDENT3 wrote the summaries for the protocols: (List all the protocols that STUDENT3 worked on).
You could also mention STUDENT1 and STUDENT2 collectively worked on: (List all the protocols that they worked together, if some of the protocols were studied as a pair or the entire team. But make sure to indicate individual efforts too! But do not simply say all the students worked on all the protocols. That is a lazy separation of responsibilities and a very unrealistic separation of works.) 
If there is a member that did not contribute to the report at all, please indicate that in the report. Individual submissions can be made in case of such conflicts. If you are part of the team, it is your responsibility to make sure you contribute and the final report has your contributions and your name is in the report with your contributions clearly identified. Insufficient contributions attributed to you will lead to a lower score for you, even if the report in general is of a great quality. 
Ideally, split the protocols equally. Each student can then review the other two teammates’ writings. Since there are 77 modules, each team member should aim to equally contribute. If you are a team of 3, it would be 25 – 26 modules per student. If you are a team of 2, that would be 38 – 39 modules per student. If you must choose as an individual (applicable if you were unavailable to be in-person and take part as team), you must still complete all the 77 modules for full points. The rationale is this to be a peer learning activity, and choosing to be a team of a single member is discouraged.
Protocol Summaries
These should be summaries and thoughts from your own understanding of the implementation, rather than text paraphrased from the product documentation (or worse, random blog posts and ChatGPT). Language errors and grammar errors do not negatively affect your points. Therefore, it is not necessary to use ChatGPT to fix your language. Grammarly is ok if you like to check for typos. But do not use the GenAI features of Grammarly Premium to generate chunks of text for the report. Each classes in the module and their code comments can be a good resource to understanding the code. Feel free to copy-paste code segments to highlight certain observations. The space given below is a rough estimate. It can be longer as needed and not all the protocols will have the same level of details and complexity. Some may need more analysis. Especially, it makes sense when you decide to present a protocol as a team, you also have a deeper understanding of that protocol and want to elaborate one in finer detail than the others. That is ok. Please do not simply copy-paste or paraphrase the code comments. That will not properly meet the learning goals. The goal is a classic code review and understanding the modules. The writing is just notes for your reference and for the instructor to grade your effort.

# DNS RESOLVER PRESENTATION

6lowpan

6lowpan provides support and IPv6 compression IEEE.

802

Security at the switch/Wi-Fi port. When you plug in, it checks who you are before letting your traffic on the LAN.

8021q

Adds VLAN tags to Ethernet frames. One cable can carry multiple “virtual” networks that stay separate.

9p

Makes remote resources look like local files. You can mount services/devices and use them with normal file reads/writes.

Appletalk

Apple’s older networking so Macs could find and share stuff on a local network. Mostly legacy now.

Atm

High-speed networking using fixed-size cells. Aimed at steady, predictable traffic on WANs/LANs

ax25

Point-to-point packet radio. Can carry other simple protocols

batman-adv

“Better Approach To Mobile Ad-hoc Networking.” A kernel Layer-2 mesh that forwards across multiple hops, wired or wireless.

bluetooth/bnep

Bnep is used for ethernet emulation as a layer on top of bluetooth. Required for bluetooth PAN.

bluetooth/cmtp

Cmtp is a transport layer used for CAPI messages. Bluetooth common ISDN access profile requires it. 

bluetooth/hidp

HIDP is the transport layer for HID reports. Human interface device points in bluetooth require this. 

bluetooth/rfcomm

RFCOMM is used to make a connection oriented stream transport. Some bluetooth applications that use dialup networking and obex all require this. 

bpf

Tiny programs the kernel can run to filter/observe packets or enforce simple rules. Handy without writing full drivers.

bridge/netfilter

NETFILTER is a configuration that utilizes INET and NETFILTER. This implementation allows the user to classify packets using the NETFILTER infrastructure. NETFILTER keeps track of what packets have moved through a machine. This is primarily used to increase the accuracy of packet filtering. 

caif

CAIF stands for communication CPU to application CPU interface, its a packet based connection oriented mux protocol for use on certain modem platforms.

can

CAN stands for controller area network. Its a networking technology used in automation, embedded devices and automotive fields. 

ceph

Ceph is a scalable file system. Its a cluster that has object block and file interface features.

core

Shared networking plumbing in the kernel: sockets, buffers, and helpers that everything else uses.

dcb

Data Center Bridging. Ethernet tweaks so different traffic types (like storage) get the right treatment and don’t drop.

dccp
DROPPED
devlink

Structured control path for smart NICs/switch chips. Query settings, update firmware, and grab detailed stats.

dns_resolver

This implementation is used to query DNS servers for information. In CIFS, this is used to resolve UNC hostname elements to an IP address. In AFSDB records, this is used to locate a cell’s volume location database servers when performing a DNS query.

dsa

Distributed Switch Architecture. Lets Linux drive embedded switch chips and expose real per-port interfaces.

ethernet

The basic Layer-2 frame/MAC world most networks use. VLANs and lots of other features sit on top of it.

ethtool

Kernel interface for NIC knobs. Check speed/duplex, offloads, queues, pause frames, and driver/firmware info.

handshake

Kernel helper for doing standard crypto/key-exchange handshakes, instead of every driver rolling its own.

hsr
"High-Avalibility Seamless Redundancy" 
Whenever a ethernet data frame is sent out from a hsr enabled device (a ring network of doubly attached nodes) it is duplicated and also sent the oposite direction. This allows for redundancy with no down time if the frame fails. 











ieee802154













ife













ipv4













ipv6/ila













ipv6/netfilter













iucv













kcm













key













l2tp













l3mdev













lapb













llc













mac80211













mac802154













mctp













mpls













mptcp













ncsi













netfilter/ipset













netfilter/ipvs













netlabel
Allows explicit packet labeling support.












netlink
Socket monitoring interface.












netrom
Protocol used for radio packet communication. 












nfc/hci
"Near Feild Communication" 












nfc/nci













nsh













openvswitch













packet













phonet













psample













qrtr













rds













rfkill













rose













rxrpc













sched













sctp













smc













strparser













sunrpc/auth_gss













sunrpc/xprtrdma













switchdev













tipc













tls













unix













vmw_vsock















wireless













x25












xdp















xfrm

